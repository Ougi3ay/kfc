# -*- coding: utf-8 -*-
"""Combiner Strategies

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19x5oGDjLE1fxaVIdN7-YKApgOjTc7tLo
"""

"""
Combiners: Abstract and Concrete Aggregation Strategies
"""

from typing import Dict, Type
import numpy as np
from scipy import stats as sp_stats
from abc import ABC, abstractmethod

class BaseCombiner(ABC):
    """
    Abstract base class for all combiners.

    A combiner takes the M predictions from the M candidate models
    and aggregates them into a single final prediction.
    """

    @abstractmethod
    def combine(self, candidate_predictions):
        """
        Combine predictions from M candidate models.

        Parameters
        ----------
        candidate_predictions : array-like of shape (n_samples, n_candidates)
            The predictions from each of the M candidate models.

        Returns
        -------
        final_predictions : array-like of shape (n_samples,)
        """
        pass

    def combine_proba(self, candidate_probas):
        """
        Combine probabilities from M candidate models.

        Parameters
        ----------
        candidate_probas : array-like of shape (n_samples, n_classes, n_candidates)
            The predicted probabilities from each of the M candidate models.

        Returns
        -------
        final_probas : array-like of shape (n_samples, n_classes)
        """
        # Default implementation: mean averaging
        return np.mean(candidate_probas, axis=2)


class MeanCombiner(BaseCombiner):
    """
    A simple combiner for regression that averages the predictions.
    """

    def combine(self, candidate_predictions):
        """
        Returns the mean of the predictions along the candidate axis.

        Parameters
        ----------
        candidate_predictions : array-like of shape (n_samples, n_candidates)

        Returns
        -------
        final_predictions : array-like of shape (n_samples,)
        """
        return np.mean(candidate_predictions, axis=1)


class VotingCombiner(BaseCombiner):
    """
    A simple combiner for classification that takes a majority vote.
    """

    def combine(self, candidate_predictions):
        """
        Returns the mode (most frequent label) along the candidate axis.

        Parameters
        ----------
        candidate_predictions : array-like of shape (n_samples, n_candidates)

        Returns
        -------
        final_predictions : array-like of shape (n_samples,)
        """
        # sp_stats.mode returns mode and count. We just want the mode.
        # keepdims=False would be ideal, but axis=1 is needed
        mode_result = sp_stats.mode(candidate_predictions, axis=1)

        # Ensure correct shape
        if isinstance(mode_result.mode, np.ndarray):
             return mode_result.mode.ravel()
        else:
             # Handle older scipy versions
             return mode_result[0].ravel()



# --- TODO for a full package ---
# class GradientCOBRARegressorCombiner(BaseCombiner):
#     """
#     An advanced combiner based on the Gradient COBRA paper, as
#     cited in the original KFC GitHub repository.
#     This would require fitting the combiner on the predictions.
#     """
#     def fit(self, X, y):
#         # This would need access to the candidate predictions on X
#         # which complicates the BaseKFC API, suggesting the combiner
#         # might need to be fit *inside* the BaseKFC.fit method.
#         pass
#
#     def combine(self, candidate_predictions):
#         # ... implementation ...
#         pass

class CombinerFactory:
    """Factory for creating combiners by name."""
    _registry: Dict[str, Type[BaseCombiner]] = {
        'mean' : MeanCombiner,
        'voting' : VotingCombiner
    }

    @classmethod
    def register(cls, name: str, combiner_class: Type[BaseCombiner]):
        """Register a new combiner class."""
        if not issubclass(combiner_class, BaseCombiner):
            raise ValueError("combiner_class must inherit from BaseCombiner")
        cls._registry[name.lower()] = combiner_class

    @classmethod
    def create(cls, name: str, **kwargs) -> BaseCombiner:
        """Instantiate a combiner by name."""
        name = name.lower()
        if name not in cls._registry:
            raise ValueError(f"Unknown combiner: {name}")
        return cls._registry[name](**kwargs)